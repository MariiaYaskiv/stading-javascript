//Полиморфизм
//Это проектирование объектов, разделяющих поведение.

/*Возьмем для примера абстрактный класс «Автомобиль», 
который наследуют два конкретных класса – «Спортивный автомобиль» и «Грузовой автомобиль».

И спортивные, и грузовые автомобили будут обладать общими характеристиками и
 будут иметь возможность выполнять общие для всех автомобилей действия, которые указаны в абстрактном классе-родителе,
  но конкретная реализация этих действий может быть разной.

Например, общее для всех автомобилей действие «завестись» 
у спортивного автомобиля может быть реализовано путем нажатия кнопки, а у грузового - с помощью ключа.
 Один результат – разные решения. В этом и состоит полиморфизм.*/

class Human {
    constructor(name) {
      this.name = name;
    }
  
    say() {
      return `Hello, my name is ${this.name}, I like travelling`;
    }
  }
  
  class Men extends Human {
    constructor(name) {
      super(name)
    }
    // Берем метод say у родителя.
  }
  
  class Coder extends Human {
    constructor(name) {
      super(name)
    }
  
    say() {
      // Переопределяем метод родителя say для отображения нового значения.
      return `Hello, my name is ${this.name}, I like coding`;
    }
  }
  
  const alex = new Men('Alex');
  const leo = new Coder('Leo');
  
  alex.say() // "Hello, my name is Alex, I like travelling"
  leo.say() // "Hello, my name is Leo, I like coding"

  ///////////////////////////////////////////////////////////////////////////////////////////////////

  //Наследование
  /*Например, пастушьи собаки обладают уникальной способностью пасти животных. 
  Все пастушьи собаки — собаки, но не все собаки — пастушьи.
   Для этого различия создается дочерний класс HerdingDog из родительского класса Dog, 
   а затем добавляется уникальное поведение herd ().

Преимущества наследования в том, что программы могут создавать общий родительский класс, 
а затем (при необходимости) создавать более конкретные дочерние классы.*/

  class Human {
    constructor(name) {
      this.name = name;
    }
  
    sayMyName() {
      return 'Hello, I am ' + this.name;
    }
  }
  
  class Men extends Human {
    constructor(name) {
      super(name)
    }
  }
  class Coder extends Human {
    constructor(name) {
      super(name)
    }
  }
  
  const alex = new Men('Alex');
  const leo = new Coder('Leo');
  
  alex.sayMyName() // Hello, I am Alex
  leo.sayMyName() // Hello, I am Le

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  //Абстракция
//фокусировка разработчика на конкретных свойствах объекта зависит от тех задач, которые призван решать объект.

/*Возьмем пример, связанный с компьютерной игрой. Метод Attack может содержать много строк кода. 
Этот код указывает, как героя можно атаковать и как атака повлияет на его здоровье. 
Вражескому объекту не нужно знать, как работает атака. 
Достаточно того, что она ухудшит показатели героя.*/

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//Інкапсуляція
